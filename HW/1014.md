# Ch5
## Question
### 5.6.
Consider the following program.
```cpp
boolean blocken [2];
int turn;
void P (int id)
{
	while (true) {
		blocked[id] = true;
		while (turn != id) {
			while (blocked[1-id])
				/* do nothing */;
			turn = id;
		}
		/* critical section */
		blocked[id] = false;
		/* remainder */
	}
}
void main()
{
	blocked[0] = false;
	blocked[1] = false;
	turn = 0;
	parbegin (P(0), P(1));
}
```

This software solution to the mutual exclusion problem for two processes is proposed in \[HYMAK66\]. Find a counterexample that demonstrates that this solution is incorrect. It is interesting to note that even the *Communications of the ACM* was fooled on this one.

### 5.8.
Now consider a version of the bakery algorithm without the variable `choosing`. Then we have
```c
int number[n];
while (true) {
	number[i] = 1 + getmax(number[], n);
	for (int j = 0; j < n; j++){
		while ((number[j] != 0) && (number[j],j) < (number[i],i)) { };
	}
	/* critical section */;
	number [i] = 0;
	/* remainder */;
}
```

Dose this version violate mutual exclusion? Explain why or why not.

### 5.10.
It should be possible to implement general semaphores using binary semaphores. We can use the operations `semWaitB` and `semSignalB` and two binary semaphores, `delay` and `mutex`. Consider the following:
```c
void semWait(semaphore s)
{
	semWaitB(mutex);
	s--;
	if (s < 0) {
		semSignalB(mutex);
		semWaitB(delay);
	}
	else SemsignalB(mutex);
}
void semSignal(semaphore s);
{
	semWaitB(mutex);
	s++;
	if (s <= 0)
		semSignalB(delay);
	semSignalB(mutex);
}
```

Initially, *s* is set to the desired semaphore value. Each `semWait` operation decrements *s*, and each `semSignal` operation increments *s*. The binary semaphore mutex, which is initialized to 1, assures that there is mutual exclusion for the updating of *s*. The binary semaphore delay, which is initialized to 0, is used to block processes.

There is a flaw in the preceding program. Demonstrate the flaw and propose a change that will fix it. *Hint:* Suppose two processes each call `semWait(s)` when `s` is initially 0, and after the first has just performed `semWaitB(delay)` but not performed `semWaitB(delay)`, the second call to `semWait(s)` proceeds to the same point. All that you need to do is move a single line of the program.

---

## Answer
