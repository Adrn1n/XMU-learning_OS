# Ch5
## Question
### 5.6.
Consider the following program.
```cpp
boolean blocken [2];
int turn;
void P (int id)
{
	while (true) {
		blocked[id] = true;
		while (turn != id) {
			while (blocked[1-id])
				/* do nothing */;
			turn = id;
		}
		/* critical section */
		blocked[id] = false;
		/* remainder */
	}
}
void main()
{
	blocked[0] = false;
	blocked[1] = false;
	turn = 0;
	parbegin (P(0), P(1));
}
```

This software solution to the mutual exclusion problem for two processes is proposed in \[HYMAK66\]. Find a counterexample that demonstrates that this solution is incorrect. It is interesting to note that even the *Communications of the ACM* was fooled on this one.

### 5.8.
Now consider a version of the bakery algorithm without the variable `choosing`. Then we have
```c
int number[n];
while (true) {
	number[i] = 1 + getmax(number[], n);
	for (int j = 0; j < n; j++){
		while ((number[j] != 0) && (number[j],j) < (number[i],i)) { };
	}
	/* critical section */;
	number [i] = 0;
	/* remainder */;
}
```

Dose this version violate mutual exclusion? Explain why or why not.

### 5.10.
It should be possible to implement general semaphores using binary semaphores. We can use the operations `semWaitB` and `semSignalB` and two binary semaphores, `delay` and `mutex`. Consider the following:
```c
void semWait(semaphore s)
{
	semWaitB(mutex);
	s--;
	if (s < 0) {
		semSignalB(mutex);
		semWaitB(delay);
	}
	else SemsignalB(mutex);
}
void semSignal(semaphore s);
{
	semWaitB(mutex);
	s++;
	if (s <= 0)
		semSignalB(delay);
	semSignalB(mutex);
}
```

Initially, *s* is set to the desired semaphore value. Each `semWait` operation decrements *s*, and each `semSignal` operation increments *s*. The binary semaphore mutex, which is initialized to 1, assures that there is mutual exclusion for the updating of *s*. The binary semaphore delay, which is initialized to 0, is used to block processes.

There is a flaw in the preceding program. Demonstrate the flaw and propose a change that will fix it. *Hint:* Suppose two processes each call `semWait(s)` when `s` is initially 0, and after the first has just performed `semSignalB(mutex)` but not performed `semWaitB(delay)`, the second call to `semWait(s)` proceeds to the same point. All that you need to do is move a single line of the program.

---

## Answer
### 5.6.
When started, `turn=0`, so `P(0)` enters the critical section first. `P(1)` is stuck in the `while(turn!=id)` loop. Then, when `P(0)` executes `blocked[id]=false`, `P(1)` can exit the loop. However, if `P(0)` re-enters the `while(turn!=id)` loop before `P(1)` can execute `turn=id`, both `P(0)` and `P(1)` can enter the critical section simultaneously.

### 5.8.
No. For example, consider `n=2` with processes `i=0` and `i=1`.  Initially, both processes `i=0` and `i=1` executes `getmax(number[],n)` simultaneously, so they will both obtain `number=1+0=1`.  However, if process `i=1` proceeds to the waiting loop before process `i=0` can update its `number`, then `number[0]` is still `0`. As a result, process `i=1` can enter the critical section. After that, process `i=0` updates it's `number` to `1`, as `(1,0)<(1,1)`, it can also enter the critical section.

### 5.10.
- Flaw
	Just as the *hint* mentioned. If both processes have not executed`semWaitB(delay)`  before 2 `semSignal(s)` occur and they all finish their process, only one of these 2 processes will be released since `delay` has just 2 states.
- Fix
	Add an else statement before `semSignalB(mutex);` in `semSignal()` and add a `semSignalB(mutex);` after `semWait(delay)` in `semWait()`
