# Ch4
## Question
### 4.2.
In the discussion of ULTs versus KLTs, it was pointed out that a disadvantage of ULTs is that when a ULT executes a system call, not only is that thread blocked, but also all of the threads within the process are blocked. Why is that so?

### 4.7.
Many current language specifications, such as for C and C++, are inadequate for multithreaded programs. This can have an impact on compilers and the correctness of code, as this problem illustrates. Consider the following declarations and function definition:
```c
int global_posiitiives=0;
typedef struct list{
	struct list *next;
	double val;
} *list;

void count_positives(list l)
{
	list p;
	for(p=l;p;p=p->next)
		if(p->val>0.0)
			++global_positives;
}

```

Now consider the case in which thread A performs
```c
count_positives(<list containing only negative values>);
```

while thread B performs
```c
++global_positives;
```

- a. What does the function do?
- b. The C language only addresses single-threaded execution. Does the use of two parallel threads create any problems or potential problems?

### 4.9
Consider the following code using the POSIX threads API:
`thread2.c`
```c
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
int myglobal;
	void *thread_function(void *arg){
		int i,j;
		for(i=0;i<20;i++){
			j=myglobal;
			j=j+1;
			printf(".");
			fflush(stdout);
			sleep(1);
			myglobal=j;
		}
		return NULL;
}

int main(void){
	pthread_t mythread;
	int i;
	if(pthread_create(&mythread,NULL,thread_function,
		NULL)){
		printf(ldquo;error creating thread.");
		abort();
	}
for(i=0;i<20;i++){
	myglobal=myglobal+1;
	printf("o");
	fflush(stdout);
	sleep(1);
}
if(pthread_join(mythread,NULL)){
	printf("error joining thread.");
abort();
}
printf("\nmyglobal equals %d\n",myglobal);
exit(0);
}

```

In `main()` we first declare a variable called mythread, which has a type of pthread_t. This is essentially an ID for a thread. Next, the `if` statement creates a thread associated with `mythread`. The call `pthread_create()` returns zero on success and a nonzero value on failure. The third argument of `pthread_create()` is the name of a function that the new thread will execute when it starts. When this `thread_function()` returns, the thread terminates. Meanwhile, the main program itself defines a thread, so that there are two threads executing. The `pthread_join` function enables the main thread to wait until the new thread completes.
- a. What does this program accomplish?
- b. Here is the output from the executed program
	```shell
	$ ./thred2
	..o.o.o.o.oo.o.o.o.o.o.o.o.o.o..o.o.o.o.o
	myglobal equals 21
	```
	Is this the output you would expect? If not, what has gone wrong?
